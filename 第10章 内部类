    可以将一个类的定义放在另一个类的定义内部，这就是内部类。
    内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部类的可视性。然而必须要了解，内部类与组合是完全不同的概念，这一点
 很重要。
 
1 创建内部类
    创建内部类的方式就如同你想的一样————把类的定义置于外围类的里面。如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个
对象的类型：OuterClassName.InnerClassName。

2 链接到外部类
    到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用的，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与
制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
    所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类
对象的引用。然后，在你访问此外围类地成员时，就是用那个引用来选择外围类的成员。

3 使用.this与.new
    如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此
没有任何运行时开销。下面的例子展示了如何使用.this：
    public class DotThis {
        void f() { System.out.println("DotThis.f()"); }
        public class Inner {
            public DotThis outer {
                return DotThis.this;
            }
        }
        public Inner inner { return new Inner(); }
        public static void main(String[] args) {
            DotThis dt = new DotThis();
            DotThis.Inner dti = dt.inner();
            dti.outer().f();
        }
    }/*output
    DotThis.f()
    */
    有时你可能想要告知某些其他对象，去创建某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用。例如：
    public class DotNew {
        public class Inner {}
        public static void main(String[] args) {
            DotNew dn = new DotNew();
            DotNew.Inner dni = dn.new Inner();
        }
    }
    要想创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew，而是必须使用外部类的对像来创建该内部类的对象，因此你不必声明（实际上你不能
声明）dn.new DotNew.Inner();

4 内部类与向上转型
    当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。这是因为此内部类————某个接口的实现————能够完全不可见，并且不可用，
所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。
    private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，
由于不能访问任何新增加的，原本不属于公共接口的方法，所以扩展接口是没有价值的，这也给Java编译器提供了生成更高效代码的机会。

5 在方法和作用域内的内部类
    可以在一个方法里面或者在任意的作用域内定义内部类，这么做有两个理由：1）如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。2）你要解决一
个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
    在后面的例子中，先前的代码将被修改，以用来实现：
    1）一个定义在方法中的类。
    2）一个定义在作用域内的类，此作用域在方法的内部。
    3）一个实现了接口的匿名类。
    4）一个匿名类，它扩展了有非默认构造器的类。
    5）一个匿名类，它执行字段初始化。
    6）一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）。
    第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。被称作局部内部类：
    public class Parcel5 {
        public Destination destination(String s) {
            class PDestination implements Destination {
                private String label;
                private PDestination(String whereTo) {
                    label = whereTo;
                }
                public String readLabel() {return label;}
            }
            return new PDestination(s);
        }
        public static void main(String[]  args) {
            Parcel5 p = new Parcel5();
            Destination d = p.destination("Tasmania");
        }
    }
    可以在任意的作用域内嵌入一个内部类。


6 匿名内部类
    public class Parcel7 {
        public Contents contents() {
            return new Contents() {
                private int i = 11;
                public int value() { return i; }
            };
        }
        public static void main(String[] args) {
            Parcel7 p = new Parcel7();
            Contents c = p.contents();
        }
    }
    Contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起，另外，这个类是匿名的，它没有名字。更糟糕的是，看起来似乎是你正要创建一
Contents对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义”。
    这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象。” 通过new表达式返回的引用被自动向上转型为对Contents的引用。
    在这个匿名内部类中，使用了默认的构造器来生成Contents。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：
    public class Parcel8 {
        public Wrapping wrapping(int x) {
            return new Wrapping(x) {
                public int value() {
                    return super.value() * 47;     //匿名类无构造函数
                }
            };
        }
        public static void main(String[] args) {
            Parcel8 p = new Parcel8();
            Wrapping w = p.wrapping(10);
        }
    }
    只需简单地传递合适的参数给基类的构造器即可，这里是将传进new Wrapping（x）。尽管Wrapping只是一个具有具体实现的普通类，但它还是被其导出类当
    作公共 “接口” 来使用。
    public class Wrapping {
        private int i;
        public Wrapping(int x) {i = x;}
        public int value() {return i;}
    }
    在匿名类中定义字段时，还能够对其执行初始化操作：
    public class Parcel9 {
        public Destination destination(final String dest){
            return new Destination() {
                private String label = dest;
                public String readLabel() {return label;}
            };
        }
        public static void main(String[] args) {
            Parcel9 p = new Parcel9();
            Destination d = p.destination("Tasmania");
        }
    }
    JDK1.8之前使用final，JDk1.8去掉了final。
    如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为没有名字），但通过实例初始化，就能达到为匿名内部类创建一个构造器的效果
就像这样：
    abstract class Base{
        public Base(int i ){
            print("Base constructor, i = " + i);
        }
        public abstract void f();
    }
    
    public class AnonymousConstructor {
        public static Base getBase(int i) {
            return new Base(i) {
                {print("Inside instance initializer");}
                public void f() {
                    print("In anonymous f()");
                }
            };
        }
        public static void main(String[] args) {
            Base base = getBase(47);
            base.f();
        }
    }/*Output
    Base constructor, i = 47
    Inside instance initializer
    In anonymous f()
    所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制————你不能重载实例初始化方法，所以你仅有一个这样的构造器。匿名内部类与正规的
继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。
6.1 再访工厂方法
    class Implemention1 implements Service {
        private Implemention1() {}
        public void method1() {}
        public void method2() {}
        public static ServiceFactory factory = 
            new ServiceFactory() {
                public Service getService() {
                    return new  Implemention1;
                }
            };
    }
    构造器都可以是private的，并且没有任何必要去创建作为工厂的具名类。另外，你经常只需要单一的工厂对象，因此在本例中它被创建为Service实现类中的
static域。这样所产语法也更具有实际意义。

7 嵌套类
    如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普
通的内部类对象隐式地保存了一个引用，指向创建它的外围类对像。然而，当内部类是static时，就不是这样了。嵌套类意味着：
    1）要创建嵌套类的对像，并不需要其外围类的对象。
    2）不能从嵌套类的对象中访问非静态的外围类对象。
    嵌套类与普通的内部类还有一个区别。普通内部类的字段和方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类
但是嵌套类可以包含所有这些东西。
    创建嵌套类对像方法：外围类.嵌套类 嵌套类对像 = new 外围类.嵌套类();





























