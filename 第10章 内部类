    可以将一个类的定义放在另一个类的定义内部，这就是内部类。
    内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部类的可视性。然而必须要了解，内部类与组合是完全不同的概念，这一点
 很重要。
 
1 创建内部类
    创建内部类的方式就如同你想的一样————把类的定义置于外围类的里面。如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个
对象的类型：OuterClassName.InnerClassName。

2 链接到外部类
    到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用的，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与
制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
    所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类
对象的引用。然后，在你访问此外围类地成员时，就是用那个引用来选择外围类的成员。

3 使用.this与.new
    如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此
没有任何运行时开销。下面的例子展示了如何使用.this：
    public class DotThis {
        void f() { System.out.println("DotThis.f()"); }
        public class Inner {
            public DotThis outer {
                return DotThis.this;
            }
        }
        public Inner inner { return new Inner(); }
        public static void main(String[] args) {
            DotThis dt = new DotThis();
            DotThis.Inner dti = dt.inner();
            dti.outer().f();
        }
    }/*output
    DotThis.f()
    */
    有时你可能想要告知某些其他对象，去创建某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用。例如：
    public class DotNew {
        public class Inner {}
        public static void main(String[] args) {
            DotNew dn = new DotNew();
            DotNew.Inner dni = dn.new Inner();
        }
    }
    要想创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew，而是必须使用外部类的对像来创建该内部类的对象，因此你不必声明（实际上你不能
声明）dn.new DotNew.Inner();

4 内部类与向上转型
    当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。这是因为此内部类————某个接口的实现————能够完全不可见，并且不可用，
所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。
    private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，
由于不能访问任何新增加的，原本不属于公共接口的方法，所以扩展接口是没有价值的，这也给Java编译器提供了生成更高效代码的机会。

5 在方法和作用域内的内部类
    可以在一个方法里面或者在任意的作用域内定义内部类，这么做有两个理由：1）如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。2）你要解决一
个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
    在后面的例子中，先前的代码将被修改，以用来实现：
    1）一个定义在方法中的类。
    2）一个定义在作用域内的类，此作用域在方法的内部。
    3）一个实现了接口的匿名类。
    4）一个匿名类，它扩展了有非默认构造器的类。
    5）一个匿名类，它执行字段初始化。
    6）一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）。
    第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。被称作局部内部类：
    public class Parcel5 {
        public Destination destination(String s) {
            class PDestination implements Destination {
                private String label;
                private PDestination(String whereTo) {
                    label = whereTo;
                }
                public String readLabel() {return label;}
            }
            return new PDestination(s);
        }
        public static void main(String[]  args) {
            Parcel5 p = new Parcel5();
            Destination d = p.destination("Tasmania");
        }
    }
    可以在任意的作用域内嵌入一个内部类。


6 匿名内部类
    public class Parcel7 {
        public Contents contents() {
            return new Contents() {
                private int i = 11;
                public int value() { return i; }
            };
        }
        public static void main(String[] args) {
            Parcel7 p = new Parcel7();
            Contents c = p.contents();
        }
    }
    Contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起，另外，这个类是匿名的，它没有名字。更糟糕的是，看起来似乎是你正要创建一
Contents对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义”。
    这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象。” 通过new表达式返回的引用被自动向上转型为对Contents的引用。































