 1. 用构造器确保初始化
        可以假想为编写的每个类都定义一个initialize()方法。该方法的名称提醒你在使用其对象之前，应首先调用initialize()。然而，这同时意味着用户必须记得
    自己去掉用此方法。在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，Java就会在用户有能力操作对象之前
    自动调用相应的构造器，从而保证了初始化的进行。
        构造器的名称必须与类名完全相同，所以 “每个方法首字母小写” 的编码风格并不适用于构造器。构造器有助于减少错误，并使代码更易于阅读。从概念上讲，“初
    始化” 与 “创建” 是彼此独立的，然而在上面的代码中，你却找不到对initialize()方法的明确调用。在Java中， “初始化” “创建” 绑定在一起，两者不能分离。
        注意：构造器名与类名相同，无任何返回值。
        类属性域定义时初始化和通过构造器初始化差异：定义时初始化域是固定的，构造器初始化域是可以改变的。
        
 2. 方法重载
 
 5. 清理：终结处理和垃圾回收
        假定你的对象（并非使用new）获得了一块 “特殊” 的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”
    内存。为了应对这种情况，Java允许在类中定义一个名为finalize（）的方法。它的工作原理 “假定” 是这样的：一旦垃圾回收器准备好释放对象占用的内存，将首先
    调用finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize（），就能在垃圾回收时刻做一些重要的清理
    工作。
        finalize（）不同于C++中的析构函数，在C++中，对象一定会被销毁（如果程序中没有缺陷的话）；而Java里的对象却并非总是被垃圾回收。或者换句话说：
    1）对象可能不被垃圾回收。2）垃圾回收并不等于 “析构”。
        也许你会发现，只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象
    的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收器本身也有开销，要是不使用它，那就不用支付这部分开销了。
        finalize（）的用途：1）清理本地对象(通过JNI创建的对象)；2） 作为确保某些非内存资源(如Socket、文件等)释放的一个补充。记住，无论是 “垃圾回收”
    还是 “终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。
        终结条件：当对某个对象不在感兴趣————也就是它可以被清理了，这个对象应该处于某种状态，使它占用的内存可以被安全的释放。例如，要是对象代表了一个打开
    的文件，在对象被回收前程序员应该关闭这个文件。只要对象中存在没有被适当处理的部分，程序就存在很隐晦的缺陷。finalize（）可以用来最终发现这种情况——尽管
    它并不总是会被调用。如果某次finalize（）的动作使得缺陷被发现，那么就此找出问题所在——这才是人们真正关心的。
 
 6. 成员初始化
        对于方法的局部变量：必须初始化，Java以编译时错误的形式来贯彻这种保证。
        对于类的数据成员：保证都会有一个初始值（基本类型为默认初始值，对象引用为null）。
    指定初始化
        1）在定义类成员变量的地方为其赋值。 2）可以通过调用某个方法来提供初值。
 7. 构造器初始化
        可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初始值，这为编程带来了更大的灵活性（注意：无法阻止自动初始化的进行）。
    初始化顺序
        在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。
    静态数据初始化
        无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有
        对它进行初始化，那么就会获得进本类型的标准初值；如果它是一个对象的引用，那么它的默认初始化值就是null。
        
        
    
        
        
    
