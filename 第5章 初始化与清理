 1. 用构造器确保初始化
        可以假想为编写的每个类都定义一个initialize()方法。该方法的名称提醒你在使用其对象之前，应首先调用initialize()。然而，这同时意味着用户必须记得
    自己去掉用此方法。在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，Java就会在用户有能力操作对象之前
    自动调用相应的构造器，从而保证了初始化的进行。
        构造器的名称必须与类名完全相同，所以 “每个方法首字母小写” 的编码风格并不适用于构造器。构造器有助于减少错误，并使代码更易于阅读。从概念上讲，“初
    始化” 与 “创建” 是彼此独立的，然而在上面的代码中，你却找不到对initialize()方法的明确调用。在Java中， “初始化” “创建” 绑定在一起，两者不能分离。
        注意：构造器名与类名相同，无任何返回值。
        类属性域定义时初始化和通过构造器初始化差异：定义时初始化域是固定的，构造器初始化域是可以改变的。
        
 2. 方法重载
    区分重载方法：1）方法名必须相同，参数列表必须不同（参数列表参数不同，参数列表个数不同，参数列表顺序不同）。2）不能以返回值区分重载方法。
    涉及基本类型的重载
        1）如果有某个重载方法接受int型参数，它就会被调用。至于其他情况，如果传入的数据类型（实际参数类型） 小于方法中声明的形式参数类型，实际数据类
        型就会被提升。char行略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。
        2）方法接受较小的基本类型作为参数。如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。
        
 3. 默认构造器
    默认构造器（又名 “无参” 构造器）是没有形式参数的————它的作用是创建一个 “默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造
    器（无参且方法体为空）。
 
 4. this关键字
        为了能用简便、面向对象的语法来编写代码————即 “发送消息给对象”，编译器做了一些幕后工作。它暗自把 “所操作对象的引用” 作为第一参数传递给方法。假设
    你希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器 “偷偷” 传入的，所以没有标识符可用。但是，为此有个专门的关键字：this。this关键字
    只能在方法内部使用，表示对 “调用方法的那个对象” 的引用。this的用法和其他对象引用并无不同。但要注意，如果在方法内部调用同一个类的另一个方法，就不
    必使用this，直接调用即可。
        1）只有当需要明确指出对当前对象的引用时，才需要使用this关键字。例如：当需要返回当前对象的引用时，就常常在return语句里这样写。
        2）this关键字对于将当前对象传递给其他方法也很有用。
    在构造器中调用构造器
        可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可用this关键字做到这一点。
    static的含义
        static方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来倒是可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调
    用static方法。
      
 5. 清理：终结处理和垃圾回收
        假定你的对象（并非使用new）获得了一块 “特殊” 的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”
    内存。为了应对这种情况，Java允许在类中定义一个名为finalize（）的方法。它的工作原理 “假定” 是这样的：一旦垃圾回收器准备好释放对象占用的内存，将首先
    调用finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize（），就能在垃圾回收时刻做一些重要的清理
    工作。
        finalize（）不同于C++中的析构函数，在C++中，对象一定会被销毁（如果程序中没有缺陷的话）；而Java里的对象却并非总是被垃圾回收。或者换句话说：
    1）对象可能不被垃圾回收。2）垃圾回收并不等于 “析构”。
        也许你会发现，只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象
    的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收器本身也有开销，要是不使用它，那就不用支付这部分开销了。
        finalize（）的用途：1）清理本地对象(通过JNI创建的对象)；2） 作为确保某些非内存资源(如Socket、文件等)释放的一个补充。记住，无论是 “垃圾回收”
    还是 “终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。
        终结条件：当对某个对象不在感兴趣————也就是它可以被清理了，这个对象应该处于某种状态，使它占用的内存可以被安全的释放。例如，要是对象代表了一个打开
    的文件，在对象被回收前程序员应该关闭这个文件。只要对象中存在没有被适当处理的部分，程序就存在很隐晦的缺陷。finalize（）可以用来最终发现这种情况——尽管
    它并不总是会被调用。如果某次finalize（）的动作使得缺陷被发现，那么就此找出问题所在——这才是人们真正关心的。
 
 6. 成员初始化
        对于方法的局部变量：必须初始化，Java以编译时错误的形式来贯彻这种保证。
        对于类的数据成员：保证都会有一个初始值（基本类型为默认初始值，对象引用为null）。
    指定初始化
        1）在定义类成员变量的地方为其赋值。 2）可以通过调用某个方法来提供初值。
 7. 构造器初始化
        可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初始值，这为编程带来了更大的灵活性（注意：无法阻止自动初始化的进行）。
    初始化顺序
        在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。
    静态数据初始化
            无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也
        没有对它进行初始化，那么就会获得进本类型的标准初值；如果它是一个对象的引用，那么它的默认初始化值就是null。
            初始化的顺序先是静态对象（如果它们尚未因前面的对象创建过程而被初始化）而后是 “非静态” 对象。
            总结一下对象的创建过程，假设有个名为Dog的类：
            1）即使没有显示的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静
        态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
            2）然后载入Dog.class（这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
            3）当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
            4）这块存储空间会被清零，这就自动地将Dog对象中的基本类型数据都设置成了默认值，而引用则被设置成了null。
            5）执行所有出现于字段定义处的初始化动作。
            6）执行构造器。
    显示的静态初始化
            Java允许将多个静态初始化动作组成一个特殊的 “静态子句”（有时也叫做静态块），就像下面这样：
         static{ 
           //语句块 
         }
         尽管上面的代码看起来像个方法，但它实际只是一段跟在static关键字后面的代码。与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的
         一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）。
    非静态实例初始化
             Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。
         {
            //语句块
         }
         看起来它与静态初始化子句一模一样，只不过少了static关键字。这种语法对于支持 “匿名内部类” 的初始化是必须的，但是它也使得你可以保证无论调用了
         哪个显式构造器，某些操作都会发生。实例初始化子句是在构造器之前执行的。
 
 8 数组初始化    
             数组只是想同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标[]来定义和使用的。要定义一个数组，
         只需在类型后加上一对空方括号即可：int[] a1;       
         编译器不允许指定数组的大小。这就又把我们带回到有关 “引用” 的问题上。现在拥有的只是对数组的一个引用 （你已经为该引用分配了足够的存储空间），
         而且也没给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对
         花括号括起来的值组成的。在这种情况下，存储空间的分配（等价于使用new）将有编译器负责。1）例如：int[] a1 = {1, 2, 3, 4, 5};
             Java数组计数也是从第0个元素开始，所以能使用的最大下标数是length-1.要是超出这个边界，C和C++会 “默默” 地接受，并允许你访问所有内存，
         许多声名狼藉的程序错误由此而生。Java则能保护你免受这一问题的困扰，一旦访问下表过界，就会出现运行时错误 (即异常)。2）可以直接用new初始化数组
         int[] a1 = new int[元素个数]; 3)也可以用花括号括起来的列表来初始化对象数组，有两种形式：Integer[] a = {new Integer(1), 
         new Integer(2), 3,};  Integer[] b = new Integer[]{new Integer(1), new Integer(2), 3,};
     可变参数列表
            参数类型... 参数 例如：int... args。可变参数列表使得重载过程变得复杂了，但是在不使用参数调用f()时，编译器就无法知道应该调用哪一个方法
         了。（原因：再调用f()时，可变参数列表是接收的）。例如：方法为 f(int... args)，调用f()方法不会出错，数组长度为0.
 
 9 枚举类型
            在Java SE中添加了一个看似很小的特性，即enum关键字，它使得我们在需要数组并使用枚举类型集时，可以很方便地处理。。
       例如：
            public enum Spiciness {
                 NOT, MTLD, MEDIUN, HOT, FLAMING
            }
       在你创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString()方法，以便你可以很方便地显示某个enum实例的名字。编译器还会创建
       ordinal()方法，用来表示某个特定enum常量的声明顺序，以及static values()方法，用来按照enum常量的声明顺序，产生由这些常量值构成的数组。
            enum有一个特别实用的特性，即它可以在switch语句内使用。由于switch是要在有限的可能值集合中进行选择，因此它与enum正是绝佳的组合。大体上，
       你可以将enum用作另外一种创建数据类型的方式，然后直接将得到的类型拿来使用。这正是关键所在。
       
        

