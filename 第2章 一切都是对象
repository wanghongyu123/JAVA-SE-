1. 用引用操控对象：
      每种编程语言都有自己的数据操纵方式，例如：C和C++里的指针来操纵对象。在Java里一切都被视为对象，尽管一切都看作对象，但操作的标识符实际上是对象的一个“引用”。
   因此，如果想操纵一个词或句子，则可以创建一个String引用：String s; 但这里所创建的只是引用，并不是对象，如果此时向s发送一个消息，就会返回一个运行时错误。这是
   因为此时s实际上没有与任何事物相关联（即，没有真正一个词或句子），因此，一种安全的做法是：创建一个引用的同时进行初始化。 String s = "asdf";

2. 必须由你创建所有对象：
      一旦创建了一个引用，就希望它能与一个新的对象相关联，通常用new关键字来实现这一目的。例如：String s = new String("asdf");
   2.1 存储到什么地方：有六个不同的地方存储数据
      1）寄存器。这是最快的存储区，因为它位于不同于其他存储去的地方——处理器内部，但是寄存器的数量及其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也
      不能在程序中感觉到寄存器存在的任何迹象。
      2）堆栈。位于通用RAM（随机访问存储器）中，但通过 “堆栈指针” 可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内
      存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下
      移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。
      3）堆。一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存
      活多长时间。因此，在堆里分配存储有很大的灵活性。当需要创建一个对象时，只需要new写 一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵
      活性必须要付出相应的代价。用堆进行存储分配比用堆栈进行存储分配需要更多的时间。    
      4）静态存储。这里的 “静态” 是指 “在固定的位置”（尽管也在RAM里）。静态存储里存放程序运行时一直存在的数据。可用关键字static来标识某个对象的特定元素是静态的，
      但Java对象本身从来不会存放在静态存储空间里。
      5）常量存储。常量值通常直接存放在程序代码内部，这样做是安全的，因为他们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分隔离开所以在这种情况下，可
      以选择将其存放在ROM（只读存储器）中。
      6）非RAM存储。如果数据完全存活于程序之外，那么他可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是 “流对象” 和 “持久化对象”。在流对象
      中，对象转化成字节流，通常被发送给另一台机器。在 “持久化对象” 中，对象被存放于磁盘上，因此，即使程序终止，他们仍可以保持自己的状态。这种存储方式的技巧在于：
      把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的，基于RAM的对象。Java提供对轻量级持久化的支持。
   2.2 特例：基本类型：
         “基本” 类型之所以特殊对待，是因为new将对象存储在 “堆” 里，故用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采取与C和C++
      相同的方法。也就是说，不用new来创建变量，而是创建一个并非是 “引用” 的 “自动” 变量。这个变量拥有 “值”，并置于堆栈中，因此更加有效。
          Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序具有可移植性的
      原因之一。  
                    基本类型      大小       最小值        最大值           包装器类型
                    boolean       —         —            —               Boolean
                    char        16-bit     Unicode 0    Unicode 2^16-1   Character
                    byte        8-bit      -128         +127             Byte
                    short       16-bit     -2^15        +2^15-1          Short
                    int         32-bit     -2^31        +2^31-1          Integer
                    long        64-bit     -2^63        +2^63-1          Long
                    float       32-bit     IEEE754      IEEE754          Float
                    double      64-bit     IEEE754      IEEE754          Double
      所有数值类型都有正负号，所以不要去寻找无符号的数值类型。
          Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体上属于 “包装器类” 的范畴，但二者没有对应的基本类型。不过，这两个类包含的方法，提供的
      操作与对基本类型所执行的操作相似。只不过必须以方法调用方式取代运算符方式来实现。由于这么做复杂了许多，所以运算速度会比较慢。这这里，我们以速度换取了精度。
          BigInteger支持任意精度的整数，也就是说，在运算中，可以准确的表示任何大小的整数值，而不会丢失任何信息。
          BigDecimal支持任何精度的定点数，例如，可以用它进行精度的货币计算。
    2.3 Java中的数组
          Java确保数组会被初始化，而且不能在它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的。但由此换来的是
      安全性和效率的提高。
    
3 永远不需要销毁对象
    3.1 作用域
          在C和C++里将一个较大作用域的变量 “隐藏” 起来的做法，在Java里是不允许的。因为Java设计者认为这样做会导致程序混乱。
    3.2 对象的作用域
          Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。 Java有一个垃圾回收器，用来监视用new创建的所
       有对象，并辨别那些不会被引用的对象。随后，释放这些对象的内存空间，以便其他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对
       像，一旦不再需要，他们就会自行消失。

4 创建新的数据类型：类
          大多数面向对象的程序设计语言习惯用关键字class来表示 “我准备告诉你一种新类型的对象看起来像什么样子”。class这个关键字之后紧跟着的是新类型的名称。
       例如： class ATypeName {/*Class body goes here*/ }
          你已经可以用new来创建这种类型的对象 ATypeName a = new ATypeName（）;
    4.1 字段和方法
          字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本类型中的一种。如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与
       一个实际的对象相关联。
          基本成员默认值：若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。局部变量必须初始化。
                              基本类型           默认值
                              boolean           false
                              char              '\u0000'(null)
                              byte              (byte)0
                              short             (short)0
                              int               0
                              long              0L
                              float             0.0f
                              double            0.0d
5 方法、参数和返回值
          方法的基本组成部分包括：名称、参数、返回值和方法体。下面是它最基本的形式：
        ReturnType methodName( /* Argument list */) {
            /* Method body */
        }
          对象调用方法：objectName.methodName(arg1, arg2, arg3);
          面向对象的程序设计通常简单地归纳为 “向对象发送消息”。
          
     5.1 参数列表
            方法的参数列表指定要传递给方法什么样的信息。正如你可能料想的那样，这些信息像Java中的其他信息一样，采用的都是对象形式。因此，在参数列表中
         必须指定每个所传递对象的类型及名字。像Java中任何传递对象的场合一样，这里传递的实际上也是引用，并且引用的类型必须正确。（基本类型除）

6 构建一个Java程序
     6.1 名字可见性
             为了避免与其他类中的函数名相冲突，Java设计者希望程序员反过来使用自己的Internet域名，因为这样可以保证它们可定是独一无二的。由于我的域名
         是MindView.net，所以我的类库就被命名为net.mindview.utility.foibles。反转域名后，句点就用来代表子目录的划分。
     6.2 运用其他构件
             导入一个类，例如：import java.util.ArrayList; 导入util里的类，import java.util.*;
     6.3 static 关键字
            static满足两种情形，一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建对少对象，甚至根本就不创建任何对象。另一种情形是，希望
         某个方法不予包含他的类的任何对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。
              
7 注释和嵌入式文档
     单行注释： // This is one-line comment
     以/*注释：  
              /* This is a comment
               * that continus
               * across lines
               */
8 注释文档
            javadoc便是用于提取注释的工具，它是JDK安装的一部分。它采用了Java编译器的某些技术，查找程序内的特殊注释标签。它不仅解析由这些标签标记的信息，也将毗
         邻注释的类名或方法名抽取出来。如此，我们就可以用最少的工作量，生成相当好的程序文档。
            javadoc输出的是一个HTML文件，可以用Web浏览器查看，此外，如果相对javadoc处理过的信息执行特殊的操作（例如，产生不同格式的输出），那么可以
         通过编写你自己的被称为 “doclets” 的javadoc处理器来实现。（所有类型的注释文档——类、域和方法——都支持嵌入式HTML）
         
     8.1 语法 
            所有javadoc命令都只能在 “/**” 注视中出现，和通常一样，注释结束于 “*/”。使用Javadoc的方式主要有两种：嵌入HTML，或使用 “文档注释”。独立文档标签是
         一些以 “@” 字符开头的命令，切要置于注释行的最前面。共有三种类型的注释文档，分别对应于注释位置后面的三种元素：类、 域和方法。 
            例如：
                  //: object/Documentation1.java
                  /** A class comment */
                  public class Documentation1 {
                        /** A field comment */
                        public int i;
                        /** A method comment */
                        public void f() {}
                  } ///:~
            注意，javadoc只能为public和protected成员进行文档注释。private和包内可访问成员的注释会被忽略掉，所以输出结果中看不到他们（不过可以用
          -private进行标记，以便把private成员的注释也包括在内）
     8.2 一些标签示例
                  这里介绍一些可用于代码文档的javadoc标签，javadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套
            的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。
            javadoc命令是用来生成自己API文档的，使用方式：使用命令行在目标文件所在目录输入javadoc +文件名.java。
            1. @see： 引用其他类
                  @see标签允许用户引用其他类的文档。javadoc会在其生成的HTML文件中，通过@see标签链接到其他文档。格式如下：
                  @see classname
                  @see fully-qualified-classname
                  @see fully-qualified-classname#method-name
            2. {@link package.class#member label}
                  该标签与@see极其相似，只是它用于行内，并且使用 “label” 作为超链接文本而不用 “See Also”
            3. {@docRoot}
                  该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接
            4. {@inheritDoc}
                  该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。
            5. @version
                  该标签的格式如下：@version version-information 其中， “version-information” 可以是任何你认为合适包含在版本说明中的重要信息。
                  如果javadoc命令行使用了 “-version” 标记，那么就从生成的HTML文档中特别提取出版本信息。
            6. @author
                  该标签的格式如下：@author author-information 其中， author-information一看便知是你的姓名，但是也可以包括电子邮件地址或者其他
                  任何事宜的信息。如果javadoc命令行使用了-author标记，name就从生成的HTML文档中特别提取作者信息。
            7. @since
                  该标签允许你指定程序代码最早使用的版本，可以在HTML Java文档中看到它被使用来指定所用的JDK版本情况。
            8. @param
                  该标签用于方法文档中，形式如下： @param paramete-name description 其中，paramete-name是方法的参数列表中的标识符，description
                  是可延续数行的文本，终止于新的文档标签出现之前。可以使用任意多个这种标签，大约每个参数都有一个这样的标签。
            9. @return
                  该标签用于方法文档，格式如下： @return description 其中，“description” 用来描述返回值的含义，可以延续数行。
            10. @throws
                  异常标签的格式如下：@throws fully-qualified-class-name description 其中fully-qualified-class-name给出一个异常类的无歧义的
                  名字，而该异常类在别处定义。description告诉你为什么此特殊类型的异常会在方法调用中出现。
            11. @deprecated
                  该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要在使用这些旧特性，因为在不久的将来它们很可能被删除。如果使用一个标记为
                  @deprecated的方法，则会引起编译器发布警告。
            
            
            
            
            
            
            
            
            
            
            
            
                   
                  
                  
         
     











